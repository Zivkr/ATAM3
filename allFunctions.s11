
; >>>>>> NOTE: this solution does not check whether each robot has already gone through the block it happens to land on <<<<<<<<<<<<<<
	; this needs some series testing, and assumes that checkSol, getMovable and movePiece all work
	; (sp) should contain the address of the array of moves


findShortest:	mov r0, -(sp)	; save the content of r0
				mov #-3, r0		; turns r0 to zero, used for increasing the size of moves, equivelent to i
				mov r1, -(sp)	; save the content of r1
				mov #-3, r1		; turns r1 to zero, used for iterating over moves, equivelent to j
				mov r2, -(sp)	; save the content of r2
				mov #0, r2		; turns r2 to zero, used for iterating moveables, as returned by getMovable, equivelent to object
				mov r4, -(sp)	; save the content of r4
				mov #moves, r4		; turns r4 to address of the array moves, but will keep the length of the array of moveables, equivelent to moveables.length
				; (sp) will be the original content of r4, 2(sp) will be to original content of r2,
				; 4(sp) will be to original content of r1, 6(sp) will be to original content of r0,
				; 12(sp) will be the address of moves
incSize:			add #3, r0			; (i=0) on first run, otherwise (i+=3)
makeMoves:		add #3, r1			; (j=0) on first run, otherwise (j+=3)
				mov #Movables, -(sp)	; allocate memory the address for Movables for getMovable
				jsr pc, getMovable	; r4 will contain the length of the array of moveable objects
				tst (sp)+			; release the memory for moveables from sp
				mov #-2, r2			; after the iterations start, this is the same as object=0
eachObject:		add #2, r2			; object+=2, instead of object++ then dividing and multiplying again
				mov 12(sp), -(sp)	; local variable to allow access to moves[j], moves[j+1], moves[j+2]
				add r1, (sp)			; (sp) should now point to moves[j]
				mov #Movables, -(sp)	; local variable to allow access to moveables[2*object], moveables[2*object+1]
				add r2, (sp)			; (sp) should now point to moveables[2*object], 2(sp) should point to moves[j]
				mov @(sp), @2(sp)		; moves[j] = moveables[2*object]
				add #2, (sp)		; (sp) should now point to moveables[2*object+1]
				add #2, 2(sp)		; 2(sp) should now point to moves[j+1]
				mov @(sp), @2(sp)		; moves[j+1] = moveables[2*object+1]
				add #2, 2(sp)		; 2(sp) should now point to moves[j+2]
				mov #'U, @2(sp)		; moves[j+2]='U
				clr -(sp)
				jsr pc, checkSol			
				cmp (sp)+, #1		; remove the result of checkSol, and if the solution worked
				beq endShortest		; end the function
				mov #'D, @2(sp)		; moves[j+2]='D
				clr -(sp)
				jsr pc, checkSol
				cmp (sp)+, #1		; remove the result of checkSol, and if the solution worked
				beq endShortest		; end the function
				mov #'L, @2(sp)		; moves[j+2]='L
				clr -(sp)
				jsr pc, checkSol
				cmp (sp)+, #1		; remove the result of checkSol, and if the solution worked
				beq endShortest		; end the function
				mov #'R, @2(sp)		; moves[j+2]='R
				clr -(sp)
				jsr pc, checkSol
				cmp (sp)+, #1		; remove the result of checkSol, and if the solution worked
				beq endShortest		; end the function
				tst (sp)+			; remove first local variable
				tst (sp)+			; remove second local variable
				cmp r2, r4			; if(2*object < moveables.length)
				blt eachObject		; then iterate for eachObject
				cmp r1, r0			; if(j<i)
				blt	makeMoves		; start creating array again
				cmp r0, MaxLen		; if(i<maxMoves)
				blt incSize			; create the array again with its new size
				; In endShortest the two local variables aren't released when called with one of the four "beq"s above?
endShortest:		tst (sp)+			; remove first local variable
				tst (sp)+			; remove second local variable
				mov (sp)+, r4		; release the content of r4
				mov (sp)+, r2		; release the content of r2
				mov (sp)+, r1		; release the content of r1
				mov (sp)+, r0		; release the content of r0
				rts pc



				
; FUNCTION - checkSol
checkSol:		cmpb (r4), #'@
				bne contFunc
				mov #Finish, -(sp)
				cmpb 6(sp), @(sp); compare the end location with finish
				bne notWork
				inc (sp)
				cmpb 7(sp), @(sp)
				bne notWork
				tst (sp)+
				mov #1, @2(sp)
				rts pc
	notWork:	tst (sp)+
				mov #0, @2(sp)
				rts pc
	contFunc:	clr -(sp)
	oneMove:	mov #param, -(sp)
				movb (r4), @(sp)
				inc r4
				inc (sp)
				movb (r4), @(sp)
				inc r4
				inc (sp)
				movb (r4), @(sp)
				inc r4
				tst (sp)+
				jsr r5, movePiece ; a single move of the given coordinates, advances r5.
				param: .byte 2, 2, 'U
				.even
				tstb (sp) ; if the first byte is (-1) that means the move wasn't a valid move.
				;NOTE TO SELF: check if board is changed if the move is not right.
				bge okResult
				tst (sp)+ ; Frees the address of the paramaters in the stack.
				mov #0, @2(sp)
				br stop
	okResult:	mov #fakeResult, -(sp)
				jsr pc, checkSol
				tst(sp)+
	stop:		tst(sp)+ ; freeing the location of the character in the stack(location after movePiece)
				rts pc

				

; FUNCTION - getMovable
getMovable:	mov r3, -(sp) ; Saving the old r3 in the stack
			mov #board, -(sp)
			clr -(sp)
			mov nCols, r4

	eachRow:mov nRows, r3
	eachCol:cmpb @2(sp), #'A
			beq cont1
			cmpb @2(sp), #'R
			beq	cont1
			inc 2(sp)
			br nextRow
	cont1:	cmpb @2(sp), #'A
			bne cont2
			mov 10(sp), tempArrLoc
			mov #array, 10(sp) ; 10(sp) stores the result array.
	cont2:	mov nRows, -(sp)
			sub r4, (sp)
			movb (sp)+,@10(sp)
			inc 10(sp)
			mov nCols, -(sp)
			sub r3, (sp)
			movb (sp)+,@10(sp)
			cmpb @2(sp), #'A
			bne iterate
			mov tempArrLoc, 10(sp)
			dec 10(sp)
	iterate:inc 10(sp)
			inc 2(sp) 	; Holds the address of the current cell in the array.
			inc (sp) 	; Holds the length of the array.
	nextRow:sob r3, eachCol		; Going through each column in a certain row.
			sob r4, eachRow		; Going through each row in the array.
			
			mov (sp)+, r4
			tst (sp)+
			mov (sp)+, r3 ; Not deleted when inserted into program
			tst (sp)+ ; Needs to be deleted when inserted into program - Return address
			mov #array, (sp)
			
			
; FUNCTION - movePiece
movePiece:		mov pc, sp	; find a way to place the parameters corectly!
				tst -(sp)
				mov #5002, r5
				mov (r5)+, -(sp) ; the row, 4(sp)
				mov (r5)+, -(sp) ; the column, 2(sp)
				mov (r5)+, -(sp) ; the direction, (sp)
				cmp 2(sp), #0	; if the column is negative
				blt badInput
				cmp 4(sp), #0	; if the row is negative
				blt badInput
				cmp 2(sp), nCols	; if the column is too big
				bge badInput
				cmp 4(sp), nRows	; if the row is too big
				bge badInput
				mov #board, -(sp) ; (sp) is board, 2(sp) is the direction, 4(sp) is the column, 6(sp) is the row
				mov r0, -(sp) ; save r0 in sp
				mov r1, -(sp) ; save r1 in sp
				; (sp) is the content of r1; 2(sp) is the content of r0; 
				; 4(sp) is board, 6(sp) is the direction
				; 10(sp) is the column, 12(sp) is the row
				mov 12(sp), r0 ; r0 is now the row index
				mul nCols, r0 ; multiply row index by row width
				add 10(sp), r1 ; r1 now contains the index in board we need to move initially
				add r1, 4(sp) ; the address of board has been moved up to the index, all in 4(sp)
				cmpb @4(sp), #'B	; if the coordinates point to a block  <<< the address at @4(sp) can be odd
				beq wrongType
				cmpb @4(sp), #0	; if the coordinates point to an empty cell
				beq wrongType
				cmpb 6(sp), #'U
				beq callUp
				cmpb 6(sp), #'D
				beq callDown						; note: the checks for block and empty cells need to clean the sp better than badInput
				cmpb 6(sp), #'L
				beq callLeft
				cmpb 6(sp), #'R
				beq callRight
endMovePiece:	mov (sp)+, r1	; release r1
				mov (sp)+, r0	; release r0
				tst (sp)+		; release the board
				tst (sp)+ 		; release the direction
				movb (sp), 3(sp); release the column and put it in the lsb for the next cell
				tst (sp)+ 		; release  the row 
				; (sp) will be row, 1(sp) will be column
				; mov (sp)+, (sp) ; might ruin something important for something that has to do with main
				halt
wrongType:		tst (sp)+
				tst (sp)+
				tst (sp)+
badInput:		mov #-1, 4(sp)	; places -1 in the return value in sp
				tst (sp)+
				tst (sp)+
				halt

				
				
callUp:		jsr pc, upMove
			jmp endMovePiece
				
callDown:	jsr pc, downMove
			jmp endMovePiece

callLeft:	jsr pc, leftMove
			jmp endMovePiece

callRight:	jsr pc, rightMove
			jmp endMovePiece		



; keep moving up in board until you hit a block that stops you, keep updating the last coordinates(?) or (-1,1) if illegal
; should get input from the spm, the first being the column, the second being the row (?)
upMove:		dec 14(sp)			; decrease the row
			sub nCols, 6(sp)		; move in the board
			cmp 14(sp), 0  		; if out of bounds
			blt	badUp
			cmpb @6(sp), #0		; if colided with an object
			bne endUp
			br upMove
badUp:		mov #-1, 12(sp) 	; if illegal coordinates were reached, turns coordinates to (-1,-1)
			mov #-2, 14(sp)
endUp:		inc 14(sp)			; increases the row to indicate ending index
			rts pc



; keep moving down in board until you hit a block that stops you, keep updating the last coordinates(?) or (-1,1) if illegal
downMove:	inc 14(sp)			; increase the row
			add nCols, 6(sp)		; move in the board
			cmpb 14(sp), nRows 	; if out of bounds
			bge	badDown
			cmpb @6(sp), #0		; if colided with an object
			bne endDown
			br downMove
badDown:		mov #-1, 12(sp) 	; if illegal coordinates were reached, turns coordinates to (-1,-1)
			mov #0, 14(sp)
endDown:		dec 14(sp)			; decreases the row to indicate ending index
			rts pc


; keep moving left in board until you hit a block that stops you, keep updating the last coordinates(?) or (-1,1) if illegal
leftMove:	dec 12(sp)			; decrease the column
			sub #1, 6(sp)		; move in the board
			cmp 12(sp), 0  		; if out of bounds
			blt	badLeft
			cmpb @6(sp), #0		; if colided with an object
			bne endLeft
			br leftMove
badLeft:		mov #-2, 12(sp)		; if illegal coordinates were reached, turns coordinates to (-1,-1)
			mov #-1, 14(sp)
endLeft:		inc 12(sp)			; increases the column to indicate ending index
			rts pc


; keep moving right in board until you hit a block that stops you, keep updating the last coordinates(?) or (-1,1) if illegal
rightMove:	inc 12(sp)			; increase the column 
			add #1, 6(sp)		; move in the board
			cmpb 12(sp), nCols  ; if out of bounds
			bge	badRight
			cmpb @6(sp), #0		; if colided with an object
			bne endRight
			br rightMove
badRight:	mov #0, 12(sp) ; if illegal coordinates were reached, turns coordinates to (-1,-1)
			mov #-1, 14(sp)
endRight:	dec 12(sp)	; decreases the column to indicate ending index
			rts pc