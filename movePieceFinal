


; FUNCTION - movePiece
movePiece:		; # get the coordinates and direction
				clr -(sp)
				movb (r5)+, (sp) ; insert the row, 4(sp)
				clr -(sp)
				movb (r5)+, (sp) ; insert the column, 2(sp)
				clr -(sp)
				movb (r5)+, (sp) ; insert the direction, (sp)
				
				; # check the coordinates
				cmp 2(sp), #0	; if the column is negative
				blt badInput
				cmp 4(sp), #0	; if the row is negative
				blt badInput
				cmp 2(sp), nCols	; if the column is too big
				bge badInput
				cmp 4(sp), nRows	; if the row is too big
				bge badInput
				
				; # set 4(sp) to point to the given tile in board
				mov #board, -(sp) ; (sp) is board, 2(sp) is the direction, 4(sp) is the column, 6(sp) is the row
				mov r0, -(sp) ; save r0 in sp
				mov r1, -(sp) ; save r1 in sp
				; (sp) is the content of r1; 2(sp) is the content of r0; 
				; 4(sp) is board, 6(sp) is the direction
				; 10(sp) is the column, 12(sp) is the row
				mov 12(sp), r0 ; r0 is now the row index
				mul nCols, r0 ; multiply row index by row width
				add 10(sp), r1 ; r1 now contains the index in board we need to move initially
				add r1, 4(sp) ; the address of board has been moved up to the index, all in 4(sp)
				
				; # check if the content of the tile is correct
				cmpb @4(sp), #'B	; if the coordinates point to a block
				beq wrongType
				cmpb @4(sp), #0	; if the coordinates point to an empty cell
				beq wrongType
				
				; (sp) is the index of the moving object in array; 2(sp) is the content of r1; 4(sp) is the content of r0; 
				; 6(sp) is board; 10(sp) is the direction
				; 12(sp) is the column; 14(sp) is the row
				; # find the index of the object being moved in the array named "movables"
				;	this part assumes that the array of objects, as ordered by getMovable, is kept at "array", and its length is in r4
				mov #r4, -(sp)		; (sp) will hold the index of the moving object in array after this loop`
				asl (sp)			; (sp) contains words, so it must be twice the index of each cell in the array
				add #movables, (sp)		; get to the end of the array
				add #2, (sp)		; used to start the following loop at the beginning of the array
				mov #0, -(sp)		; used for comparing the second byte
emptyFiller:		tst (sp)+			; used for comparing the second byte
getIndex:		sub #2, (sp)		; each iteration, go to the previous object in the array		
				cmpb @0(sp), 14(sp)	; compare the first byte in the given index in array, the column, with column given to movePiece
				bne getIndex
				mov @(sp), -(sp)	; used for the next comparison
				cmpb 1(sp), 14(sp)	; compare the seccond byte in the given index in array, the row, with row given to movePiece
				bne emptyFiller
				tst (sp)+			; remove the byte advancement
				sub #movables, (sp)	; (sp) will now be the index of the moving object in movables, rather than its address
				asr (sp)			; (sp) was in bytes, but not indicates words 
				
				; (sp) is the index of the moving object in array; 2(sp) is the content of r1; 4(sp) is the content of r0; 
				; 6(sp) is board; 10(sp) is the direction
				; 12(sp) is the column; 14(sp) is the row
				
				; # move the object in the given direction
				cmpb 10(sp), #'U
				beq callUp
				cmpb 10(sp), #'D
				beq callDown						; note: the checks for block and empty cells need to clean the sp better than badInput
				cmpb 10(sp), #'L
				beq callLeft
				cmpb 10(sp), #'R
				beq callRight
				br badDirection
			
				
				; # make sure the object didn't already visit the tile it just landed on
checkReturns:	mov #helper, -(sp)			; >>>>>>>>>>>>>>>>>>>>>> the problem described below probably originates here somewhere
				mov 16(sp), r0
				mul nCols, r0
				add 14(sp), r1			; r1 should now contain the index for which the object just moved
				add r1, (sp)
				; (sp) should now point to the tile in helper which represents which objects have already passed there 
				; (sp) is the address of the tile in helper; 2(sp) is the index of the moving object in array; 
				; 4(sp) is the content of r1; 6(sp) is the content of r0; 
				; 10(sp) is board; 12(sp) is the direction
				; 14(sp) is the column; 16(sp) is the row
				mov #1, -(sp)		; this mask will be used to indicate the bit we need to check in the tile in helper to assure the object hasn't been in it
				cmp #0, @4(sp)		; if the index of the object is 0, meaning it is the astronaut, just check if it was at the given tile
				beq comparison
pushLeft:		dec 4(sp)			; move the bit in index 0 to index 4(sp)
				asl (sp)			; move the bit left once
				cmp #0, 4(sp)		; if the index left to move is 0, then just stop moving and get to comparing, otherwise keep moving
				bne pushLeft

comparison:		bitb @2(sp), (sp)	; once the bit has been pushed far enough, check if the tile the object landed on has a 1 in the corresponding bit		
				bne alreadyVisited	; if the bit at the given index is set, that means the object has already landed on this tile
				
				; # the object can legally move to the given tile in board! now mark that new square, and free the recently allocated word in sp
				bisb (sp), @2(sp)	; sets the square the object has landed on to indicate the square has been visited by the object	
				tst (sp)+			; free the mask
				tst (sp)+			; free the address in helper array
				
				; # end the function, assuming everything went smootly and the object was indeed moved to the designated direction
endMovePiece:	tst (sp)+		; release the index of the moving object
				mov (sp)+, r1	; release r1
				mov (sp)+, r0	; release r0
				tst (sp)+		; release the board
				tst (sp)+ 		; release the direction
				movb (sp), 3(sp); put the column in the same word with the row
				tst (sp)+ 		; release  the column 
				mov (sp)+, 2(sp); release and return the new coordinates
				; (sp) will be row, 1(sp) will be column
				rts r5
								
				; # end the function according to which mistake happened along the way	
				; almost the same as endMovePiece, except that it turns the return result to be (-1,-1)		
alreadyVisited:	tst (sp)+		; release the mask
				tst (sp)+		; release the tile address in helper
badDirection:	tst (sp)+		; release the index of the moving object in array
wrongType:		mov (sp)+, r1	; release r1
				mov (sp)+, r2	; release r0
				tst (sp)+		; release the board
				tst (sp)+		; release the direction
badInput:		tst (sp)+		; release the column
				tst (sp)+		; release the row
				mov #-1, 2(sp)	; place the return value
				rts r5

				
; # call the moving functions				
callUp:		jsr pc, upMove
			jmp checkReturns
				
callDown:	jsr pc, downMove
			jmp checkReturns

callLeft:	jsr pc, leftMove
			jmp checkReturns

callRight:	jsr pc, rightMove
			jmp checkReturns		

; (sp) is the address of the tile in helper; 2(sp) is the index of the moving object in array; 
; 4(sp) is the content of r1; 6(sp) is the content of r0; 
; 10(sp) is board; 12(sp) is the direction
; 14(sp) is the column; 16(sp) is the row
				
upMove:		dec 16(sp)			; decrease the row
			sub nCols, 10(sp)		; move in the board
			cmp 16(sp), 0  		; if out of bounds
			blt	badUp
			cmpb @10(sp), #0	; if colided with an object
			bne endUp
			br upMove
badUp:		mov #-1, 14(sp) 	; if illegal coordinates were reached, turns coordinates to (-1,-1)
			mov #-2, 16(sp)
endUp:		inc 16(sp)			; increases the row to indicate ending index
			rts pc

; keep moving down in board until you hit a block that stops you, keep updating the last coordinates(?) or (-1,1) if illegal
downMove:	inc 16(sp)			; increase the row
			add nCols, 10(sp)		; move in the board
			cmpb 16(sp), nRows 	; if out of bounds
			bge	badDown
			cmpb @10(sp), #0	; if colided with an object
			bne endDown
			br downMove
badDown:		mov #-1, 14(sp) 	; if illegal coordinates were reached, turns coordinates to (-1,-1)
			mov #0, 16(sp)
endDown:		dec 16(sp)			; decreases the row to indicate ending index
			rts pc

; keep moving left in board until you hit a block that stops you, keep updating the last coordinates(?) or (-1,1) if illegal
leftMove:	dec 14(sp)			; decrease the column
			sub #1, 10(sp)		; move in the board
			cmp 14(sp), 0  		; if out of bounds
			blt	badLeft
			cmpb @10(sp), #0		; if colided with an object
			bne endLeft
			br leftMove
badLeft:		mov #-2, 14(sp)		; if illegal coordinates were reached, turns coordinates to (-1,-1)
			mov #-1, 16(sp)
endLeft:		inc 14(sp)			; increases the column to indicate ending index
			rts pc

; keep moving right in board until you hit a block that stops you, keep updating the last coordinates(?) or (-1,1) if illegal
rightMove:	inc 14(sp)			; increase the column 
			add #1, 10(sp)		; move in the board
			cmpb 14(sp), nCols  ; if out of bounds
			bge	badRight
			cmpb @10(sp), #0		; if colided with an object
			bne endRight
			br rightMove
badRight:	mov #0, 14(sp) 		; if illegal coordinates were reached, turns coordinates to (-1,-1)
			mov #-1, 16(sp)
endRight:	dec 14(sp)			; decreases the column to indicate ending index <<<<<<<<<<<<doesn't return from this function properly
			rts pc
